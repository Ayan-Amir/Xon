/** Define the main block types **/
import { Node, NodeConfig } from "@tiptap/core";
import { BlockNoteEditor } from "../../../BlockNoteEditor";
import { InlineContent, PartialInlineContent } from "./inlineContentTypes";
import { DefaultBlockSchema } from "./defaultBlocks";
export type BlockNoteDOMElement = "editor" | "blockContainer" | "blockGroup" | "blockContent" | "inlineContent";
export type BlockNoteDOMAttributes = Partial<{
    [DOMElement in BlockNoteDOMElement]: Record<string, string>;
}>;
export type TipTapNodeConfig<Name extends string, ContainsInlineContent extends boolean, Options extends {
    domAttributes?: BlockNoteDOMAttributes;
} = {
    domAttributes?: BlockNoteDOMAttributes;
}, Storage = any> = {
    [K in keyof NodeConfig<Options, Storage>]: K extends "name" ? Name : K extends "content" ? ContainsInlineContent extends true ? "inline*" : "" : K extends "group" ? never : NodeConfig<Options, Storage>[K];
} & {
    name: Name;
    content: ContainsInlineContent extends true ? "inline*" : "";
};
export type TipTapNode<Name extends string, ContainsInlineContent extends boolean, Options extends {
    domAttributes?: BlockNoteDOMAttributes;
} = {
    domAttributes?: BlockNoteDOMAttributes;
}, Storage = any> = {
    [Key in keyof Node<Options, Storage>]: Key extends "name" ? Name : Key extends "config" ? {
        [ConfigKey in keyof Node<Options, Storage>["config"]]: ConfigKey extends "group" ? "blockContent" : ConfigKey extends "content" ? ContainsInlineContent extends true ? "inline*" : "" : NodeConfig<Options, Storage>["config"][ConfigKey];
    } & {
        group: "blockContent";
        content: ContainsInlineContent extends true ? "inline*" : "";
    } : Node<Options, Storage>["config"][Key];
};
export type PropSpec<PType extends boolean | number | string> = {
    values?: readonly PType[];
    default: PType;
};
export type PropSchema = Record<string, PropSpec<boolean | number | string>>;
export type Props<PSchema extends PropSchema> = {
    [PName in keyof PSchema]: PSchema[PName]["default"] extends boolean ? PSchema[PName]["values"] extends readonly boolean[] ? PSchema[PName]["values"][number] : boolean : PSchema[PName]["default"] extends number ? PSchema[PName]["values"] extends readonly number[] ? PSchema[PName]["values"][number] : number : PSchema[PName]["default"] extends string ? PSchema[PName]["values"] extends readonly string[] ? PSchema[PName]["values"][number] : string : never;
};
export type BlockConfig<Type extends string, PSchema extends PropSchema, ContainsInlineContent extends boolean, BSchema extends BlockSchema> = {
    type: Type;
    readonly propSchema: PSchema;
    containsInlineContent: ContainsInlineContent;
    render: (
    /**
     * The custom block to render
     */
    block: SpecificBlock<BSchema & {
        [k in Type]: BlockSpec<Type, PSchema, ContainsInlineContent>;
    }, Type>, 
    /**
     * The BlockNote editor instance
     * This is typed generically. If you want an editor with your custom schema, you need to
     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`
     */
    editor: BlockNoteEditor<BSchema & {
        [k in Type]: BlockSpec<Type, PSchema, ContainsInlineContent>;
    }>) => ContainsInlineContent extends true ? {
        dom: HTMLElement;
        contentDOM: HTMLElement;
        destroy?: () => void;
    } : {
        dom: HTMLElement;
        destroy?: () => void;
    };
};
export type BlockSpec<Type extends string, PSchema extends PropSchema, ContainsInlineContent extends boolean> = {
    node: TipTapNode<Type, ContainsInlineContent, any>;
    readonly propSchema: PSchema;
};
type NamesMatch<Blocks extends Record<string, BlockSpec<string, PropSchema, boolean>>> = Blocks extends {
    [Type in keyof Blocks]: Type extends string ? Blocks[Type] extends BlockSpec<Type, PropSchema, boolean> ? Blocks[Type] : never : never;
} ? Blocks : never;
export type BlockSchema = NamesMatch<Record<string, BlockSpec<string, PropSchema, boolean>>>;
type BlocksWithoutChildren<BSchema extends BlockSchema> = {
    [BType in keyof BSchema]: {
        id: string;
        type: BType;
        props: Props<BSchema[BType]["propSchema"]>;
        content: BSchema[BType]["node"]["config"]["content"] extends "inline*" ? InlineContent[] : undefined;
    };
};
export type Block<BSchema extends BlockSchema = DefaultBlockSchema> = BlocksWithoutChildren<BSchema>[keyof BlocksWithoutChildren<BSchema>] & {
    children: Block<BSchema>[];
};
export type SpecificBlock<BSchema extends BlockSchema, BlockType extends keyof BSchema> = BlocksWithoutChildren<BSchema>[BlockType] & {
    children: Block<BSchema>[];
};
type PartialBlocksWithoutChildren<BSchema extends BlockSchema> = {
    [BType in keyof BSchema]: Partial<{
        id: string;
        type: BType;
        props: Partial<Props<BSchema[BType]["propSchema"]>>;
        content: BSchema[BType]["node"]["config"]["content"] extends "inline*" ? PartialInlineContent[] | string : undefined;
    }>;
};
export type PartialBlock<BSchema extends BlockSchema = DefaultBlockSchema> = PartialBlocksWithoutChildren<BSchema>[keyof PartialBlocksWithoutChildren<BSchema>] & Partial<{
    children: PartialBlock<BSchema>[];
}>;
export type BlockIdentifier = {
    id: string;
} | string;
export {};
